"""Factory for Python dependency parsers"""
from ..base import FileFormatDetector, DependencyParser
from ..parsers.python import (
    PoetryLockParser,
    PipfileLockParser,
    RequirementsParser,
    PyprojectParser,
    PipfileParser
)


class PythonParserFactory:
    """
    Factory for creating appropriate Python dependency parsers
    
    Simplified factory that focuses on the core parsers needed for 
    dependency resolution. Uses requirements.lock as the preferred format
    when available (generated via pip-tools).
    """
    
    def __init__(self):
        self.detector = FileFormatDetector()
        
        self._parsers = {
            "requirements": RequirementsParser(),
            "poetry-lock": PoetryLockParser(),
            "pipfile-lock": PipfileLockParser(),
            "pyproject": PyprojectParser(),
            "pipfile": PipfileParser()
        }
    
    def get_parser(self, filename: str, content: str = "") -> DependencyParser:
        """
        Get appropriate parser for Python dependency file
        
        Args:
            filename: Name of the dependency file
            content: File content (used for format detection)
            
        Returns:
            Parser instance for the detected format
            
        Raises:
            ValueError: If format is not supported
        """
        try:
            format_name = self.detector.detect_python_format(filename, content)
            
            if format_name in self._parsers:
                return self._parsers[format_name]
            else:
                raise ValueError(f"Unsupported Python format: {format_name}")
                
        except Exception as e:
            raise ValueError(f"Could not determine Python parser for {filename}: {e}")
    
    def get_parser_by_format(self, format_name: str) -> DependencyParser:
        """
        Get parser by explicit format name
        
        Args:
            format_name: Explicit format identifier
            
        Returns:
            Parser instance
        """
        if format_name in self._parsers:
            return self._parsers[format_name]
        else:
            raise ValueError(f"Unknown format: {format_name}")
    
    def detect_best_format(self, available_files: dict[str, str]) -> tuple[str, str]:
        """
        Detect the best format to use from available files
        
        Priority: requirements.lock (pip-tools output) > lock files > manifests
        This prioritizes the most accurate dependency information.
        
        Args:
            available_files: Dict of {filename: content}
            
        Returns:
            Tuple of (best_filename, format_name)
        """
        # Priority order: pip-tools output first, then other lockfiles, then manifests
        priority_order = [
            ("requirements.lock", "requirements"),  # Generated by pip-tools (most accurate)
            ("poetry.lock", "poetry-lock"),         # Poetry lockfile
            ("Pipfile.lock", "pipfile-lock"),       # Pipenv lockfile  
            ("requirements.txt", "requirements"),   # Requirements manifest
            ("pyproject.toml", "pyproject"),        # Modern Python manifest
            ("Pipfile", "pipfile")                  # Pipenv manifest
        ]
        
        for filename, format_name in priority_order:
            if filename in available_files:
                return filename, format_name
        
        raise ValueError("No supported Python dependency files found")
    
    def get_supported_formats(self) -> list[str]:
        """Get list of all supported Python formats"""
        return [
            "requirements.lock",  # pip-tools output (preferred)
            "poetry.lock",
            "Pipfile.lock", 
            "requirements.txt",
            "pyproject.toml",
            "Pipfile"
        ]
    
    def can_handle_file(self, filename: str) -> bool:
        """Check if factory can handle the given filename"""
        try:
            self.detector.detect_python_format(filename, "")
            return True
        except ValueError:
            return False