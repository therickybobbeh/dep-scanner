name: Web App - Deploy to AWS

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'deploy/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: depscan-prod-cluster
  BACKEND_SERVICE: depscan-prod-backend
  FRONTEND_SERVICE: depscan-prod-frontend
  BACKEND_ECR_REPOSITORY: depscan-prod-backend
  FRONTEND_ECR_REPOSITORY: depscan-prod-frontend

permissions:
  id-token: write
  contents: read

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install backend dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -e .
        pip install pytest pytest-asyncio pytest-httpx

    - name: Run backend tests
      run: |
        cd backend
        python -m pytest -v || echo "No tests found, skipping..."

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install frontend dependencies
      run: |
        cd frontend
        rm -rf node_modules package-lock.json
        npm install

    - name: Run frontend tests
      run: |
        cd frontend
        if find src -name "*.test.*" -o -name "*.spec.*" | grep -q .; then
          npm test -- --run
        else
          echo "No frontend test files found, skipping frontend tests"
        fi

    - name: Build frontend
      run: |
        cd frontend
        npm run build

  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # Parallel Docker builds for faster deployment
    - name: Build backend and frontend images in parallel
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build and tag backend image (single build, multiple tags)
        docker build -t $ECR_REGISTRY/$BACKEND_ECR_REPOSITORY:$IMAGE_TAG -f deploy/docker/Dockerfile.backend . &
        BACKEND_PID=$!
        
        # Build and tag frontend image (single build, multiple tags)  
        docker build -t $ECR_REGISTRY/$FRONTEND_ECR_REPOSITORY:$IMAGE_TAG -f deploy/docker/Dockerfile.frontend . &
        FRONTEND_PID=$!
        
        # Wait for both builds to complete
        wait $BACKEND_PID
        wait $FRONTEND_PID
        
        # Tag latest versions (instant operation)
        docker tag $ECR_REGISTRY/$BACKEND_ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$BACKEND_ECR_REPOSITORY:latest
        docker tag $ECR_REGISTRY/$FRONTEND_ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$FRONTEND_ECR_REPOSITORY:latest
        
        # Push all tags in parallel
        docker push $ECR_REGISTRY/$BACKEND_ECR_REPOSITORY:$IMAGE_TAG &
        docker push $ECR_REGISTRY/$BACKEND_ECR_REPOSITORY:latest &
        docker push $ECR_REGISTRY/$FRONTEND_ECR_REPOSITORY:$IMAGE_TAG &  
        docker push $ECR_REGISTRY/$FRONTEND_ECR_REPOSITORY:latest &
        
        # Wait for all pushes to complete
        wait

    - name: Download backend task definition
      run: |
        aws ecs describe-task-definition --task-definition depscan-prod-backend \
          --query taskDefinition > backend-task-definition.json

    - name: Download frontend task definition  
      run: |
        aws ecs describe-task-definition --task-definition depscan-prod-frontend \
          --query taskDefinition > frontend-task-definition.json

    - name: Fill in the new backend image ID in the Amazon ECS task definition
      id: backend-task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: backend-task-definition.json
        container-name: backend
        image: ${{ steps.login-ecr.outputs.registry }}/${{ env.BACKEND_ECR_REPOSITORY }}:${{ github.sha }}

    - name: Fill in the new frontend image ID in the Amazon ECS task definition
      id: frontend-task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: frontend-task-definition.json
        container-name: frontend
        image: ${{ steps.login-ecr.outputs.registry }}/${{ env.FRONTEND_ECR_REPOSITORY }}:${{ github.sha }}

    - name: Debug task definitions
      run: |
        echo "Backend task definition:"
        if [ -f backend-task-definition.json ]; then
          echo "‚úÖ Backend task definition file exists"
          echo "Task definition ARN from downloaded file:"
          cat backend-task-definition.json | jq -r '.taskDefinitionArn // "NOT_FOUND"'
        else
          echo "‚ùå Backend task definition file not found"
        fi
        
        echo "Frontend task definition:"  
        if [ -f frontend-task-definition.json ]; then
          echo "‚úÖ Frontend task definition file exists"
          echo "Task definition ARN from downloaded file:"
          cat frontend-task-definition.json | jq -r '.taskDefinitionArn // "NOT_FOUND"'
        else
          echo "‚ùå Frontend task definition file not found"
        fi
        
        echo "Render step outputs (these are the rendered files):"
        echo "Backend: ${{ steps.backend-task-def.outputs.task-definition }}"
        echo "Frontend: ${{ steps.frontend-task-def.outputs.task-definition }}"
        
        echo "Contents of rendered files:"
        echo "Backend rendered file structure:"
        cat ${{ steps.backend-task-def.outputs.task-definition }} | jq 'keys'
        echo "Frontend rendered file structure:"  
        cat ${{ steps.frontend-task-def.outputs.task-definition }} | jq 'keys'

    - name: Register and deploy task definitions in parallel
      run: |
        # Register new task definitions and get ARNs (in parallel for speed)
        echo "Registering task definitions in parallel..."
        
        aws ecs register-task-definition \
          --cli-input-json file://${{ steps.backend-task-def.outputs.task-definition }} > backend-register-output.json &
        BACKEND_REG_PID=$!
        
        aws ecs register-task-definition \
          --cli-input-json file://${{ steps.frontend-task-def.outputs.task-definition }} > frontend-register-output.json &
        FRONTEND_REG_PID=$!
        
        # Wait for both registrations to complete
        wait $BACKEND_REG_PID
        wait $FRONTEND_REG_PID
        
        # Extract the ARNs from registration outputs
        BACKEND_TASK_DEF=$(cat backend-register-output.json | jq -r '.taskDefinition.taskDefinitionArn')
        FRONTEND_TASK_DEF=$(cat frontend-register-output.json | jq -r '.taskDefinition.taskDefinitionArn')
        
        echo "Deploying with registered task definition ARNs:"
        echo "Backend: $BACKEND_TASK_DEF"
        echo "Frontend: $FRONTEND_TASK_DEF"
        
        # Deploy both services simultaneously for faster deployment
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.BACKEND_SERVICE }} \
          --task-definition "$BACKEND_TASK_DEF" &
        BACKEND_DEPLOY_PID=$!
        
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.FRONTEND_SERVICE }} \
          --task-definition "$FRONTEND_TASK_DEF" &
        FRONTEND_DEPLOY_PID=$!
        
        # Wait for both deployments to start
        wait $BACKEND_DEPLOY_PID
        wait $FRONTEND_DEPLOY_PID
        
        echo "‚úÖ Both services deployed successfully in parallel"
        echo "üöÄ Services are updating in the background and will be ready shortly"

    - name: Get service access info
      run: |
        echo "‚úÖ Deployment completed successfully!"
        echo ""
        echo "üìç To access your services:"
        echo "1. Go to AWS ECS Console: https://console.aws.amazon.com/ecs/"
        echo "2. Click cluster: ${{ env.ECS_CLUSTER }}"
        echo "3. Click Services ‚Üí Tasks ‚Üí Running task ‚Üí Network section"
        echo "4. Find the Public IP address"
        echo ""
        echo "üåê Access URLs:"
        echo "- Frontend: http://[PUBLIC_IP]:80"
        echo "- Backend API: http://[PUBLIC_IP]:8000/health"
        echo "- API Docs: http://[PUBLIC_IP]:8000/docs"
        echo ""
        echo "üìä Services deployed:"
        echo "- Backend: ${{ env.BACKEND_SERVICE }}"
        echo "- Frontend: ${{ env.FRONTEND_SERVICE }}"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActionsRollback

    - name: Rollback backend service
      run: |
        # Get the previous task definition
        PREVIOUS_TASK_DEF=$(aws ecs list-task-definitions --family-prefix ${{ env.ECS_CLUSTER }}-backend --status ACTIVE --sort DESC --max-items 2 --query 'taskDefinitionArns[1]' --output text)
        if [ "$PREVIOUS_TASK_DEF" != "None" ] && [ "$PREVIOUS_TASK_DEF" != "" ]; then
          echo "Rolling back backend to: $PREVIOUS_TASK_DEF"
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.BACKEND_SERVICE }} --task-definition $PREVIOUS_TASK_DEF
        else
          echo "No previous backend task definition found for rollback"
        fi

    - name: Rollback frontend service
      run: |
        # Get the previous task definition
        PREVIOUS_TASK_DEF=$(aws ecs list-task-definitions --family-prefix ${{ env.ECS_CLUSTER }}-frontend --status ACTIVE --sort DESC --max-items 2 --query 'taskDefinitionArns[1]' --output text)
        if [ "$PREVIOUS_TASK_DEF" != "None" ] && [ "$PREVIOUS_TASK_DEF" != "" ]; then
          echo "Rolling back frontend to: $PREVIOUS_TASK_DEF"
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.FRONTEND_SERVICE }} --task-definition $PREVIOUS_TASK_DEF
        else
          echo "No previous frontend task definition found for rollback"
        fi